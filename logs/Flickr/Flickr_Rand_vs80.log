nohup: ignoring input
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4632
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4639
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4642
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4651
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4627
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4661
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4651
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4616
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4648
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4633
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.46400, 0.00126
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4845
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4866
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4847
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4831
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4844
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4829
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4835
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4855
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4828
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4840
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.48420, 0.00115
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4614
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4680
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4612
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4659
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4648
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4548
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4634
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4708
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4664
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4638
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.46404, 0.00415
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4338
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4299
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4372
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4306
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4307
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4416
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4306
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4341
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4356
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4359
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.43399, 0.00353
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4681
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4682
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4680
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4675
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4675
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4663
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4685
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4672
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4670
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4676
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.46759, 0.00061
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4418
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4299
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4084
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4084
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4066
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4037
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4063
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4038
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4037
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4064
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.41190, 0.01238
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4588
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4562
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4548
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4547
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4536
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4541
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4549
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4562
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4578
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4548
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.45560, 0.00159
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4478
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4430
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4418
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4379
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4453
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4404
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4473
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4396
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4472
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
accuracy on clean test nodes: 0.4483
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.44385, 0.00362
Namespace(attack_method='Rand_Gene', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4549
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4659
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4638
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4578
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4661
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4597
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4466
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4605
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4615
ASR: 0.0000
Rand generate the trigger
precent of left attach nodes: 0.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4664
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.46032, 0.00582
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4630
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4627
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4651
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4658
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4634
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4649
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4631
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4614
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4664
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4627
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.46385, 0.00152
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4847
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4847
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4838
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4838
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4861
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4838
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4847
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4848
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4819
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
accuracy on clean test nodes: 0.4835
ASR: 0.0000
The final ASR:0.00000, 0.00000, Accuracy:0.48418, 0.00104
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='none', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
accuracy on clean test nodes: 0.4635
ASR: 0.0000
Rand sample the trigger
precent of left attach nodes: 1.000
/home/project-graph-backdoor/Backdoor/models/GAT.py:61: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  self.labels = torch.tensor(labels, dtype=torch.long)
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 147, in <module>
    test_model.fit(poison_x, poison_edge_index, poison_edge_weights, poison_labels, bkd_tn_nodes, idx_val,train_iters=args.epochs,verbose=args.debug)
  File "/home/project-graph-backdoor/Backdoor/models/GAT.py", line 67, in fit
    self._train_with_val(self.labels, idx_train, idx_val, train_iters, verbose)
  File "/home/project-graph-backdoor/Backdoor/models/GAT.py", line 98, in _train_with_val
    loss_train.backward()
  File "/root/anaconda3/envs/py38_torch110/lib/python3.8/site-packages/torch/_tensor.py", line 396, in backward
    torch.autograd.backward(self, gradient, retain_graph, create_graph, inputs=inputs)
  File "/root/anaconda3/envs/py38_torch110/lib/python3.8/site-packages/torch/autograd/__init__.py", line 173, in backward
    Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass
RuntimeError: CUDA out of memory. Tried to allocate 1.27 GiB (GPU 0; 47.54 GiB total capacity; 8.54 GiB already allocated; 724.56 MiB free; 10.11 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 132, in <module>
    poison_edge_index,poison_edge_weights = prune_unrelated_edge(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 35, in prune_unrelated_edge
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 132, in <module>
    poison_edge_index,poison_edge_weights = prune_unrelated_edge(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 35, in prune_unrelated_edge
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='prune', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 132, in <module>
    poison_edge_index,poison_edge_weights = prune_unrelated_edge(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 35, in prune_unrelated_edge
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GCN', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 135, in <module>
    poison_edge_index,poison_edge_weights,rel_nodes = prune_unrelated_edge_isolated(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 63, in prune_unrelated_edge_isolated
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GraphSage', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 135, in <module>
    poison_edge_index,poison_edge_weights,rel_nodes = prune_unrelated_edge_isolated(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 63, in prune_unrelated_edge_isolated
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
Namespace(attack_method='Rand_Samp', cuda=True, dataset='Flickr', debug=False, defense_mode='isolate', device_id=0, dropout=0.5, epochs=2000, evaluate_mode='1by1', hidden=64, no_cuda=False, prune_thr=0.4, seed=15, target_class=0, test_model='GAT', train_lr=0.02, trigger_prob=0.5, trigger_size=3, vs_ratio=0.05, vs_size=80, weight_decay=0.0005)
Rand sample the trigger
Traceback (most recent call last):
  File "run_bkd_baseline.py", line 135, in <module>
    poison_edge_index,poison_edge_weights,rel_nodes = prune_unrelated_edge_isolated(args,poison_edge_index,poison_edge_weights,poison_x,device,large_graph=False)
  File "/home/project-graph-backdoor/Backdoor/help_funcs.py", line 63, in prune_unrelated_edge_isolated
    edge_sims = F.cosine_similarity(x[edge_index[0]],x[edge_index[1]])
RuntimeError: CUDA out of memory. Tried to allocate 1.08 GiB (GPU 0; 47.54 GiB total capacity; 4.70 GiB already allocated; 890.56 MiB free; 4.71 GiB reserved in total by PyTorch) If reserved memory is >> allocated memory try setting max_split_size_mb to avoid fragmentation.  See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
